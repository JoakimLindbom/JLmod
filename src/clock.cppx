#include "clock.hpp"
#include <math.h>

Clock::Clock() {
  reset2();
}

inline void Clock::reset2() {
  step = -1.0;
}

inline bool Clock::isReset2() {
  return step == -1.0;
}

inline double Clock::getStep() {
  return step;
}

void Clock::setup(Clock* clkGiven, bool *resetClockOutputsHighPtr) {
  resetClockOutputsHigh = resetClockOutputsHighPtr;
}

inline void Clock::start2() {
  step = 0.0;
}

inline void Clock::setup(double lengthGiven, int iterationsGiven, double sampleTimeGiven) {
  length = lengthGiven;
  iterations = iterationsGiven;
  sampleTime = sampleTimeGiven;
}

void Clock::stepClock() {  // here the clock was output on step "step", this function is called at end of module::step()
  if (step >= 0.0) {  // if active clock
    step += sampleTime;
    if (step >= length) {  // reached end iteration
      iterations--;
      step -= length;
      if (iterations <= 0)
        reset2();  // frame done
    }
  }
}

void Clock::applyNewLength(double lengthStretchFactor) {
  if (step != -1.0)
    step *= lengthStretchFactor;
  length *= lengthStretchFactor;
}

int Clock::isHigh(float swing, float pulseWidth) {
  // last 0.5ms (guard time) must be low so that sync mechanism will work properly (i.e. no missed pulses)
  //   this will automatically be the case, since code below disallows any pulses or inter-pulse times less than 1ms
  int high = 0;
  if (step >= 0.0) {
    float swParam = swing;  // swing is [-1 : 1]

    // all following values are in seconds
    float onems = 0.001f;
    float period = (float)length / 2.0f;
    float swing = (period - 2.0f * onems) * swParam;
    float p2min = onems;
    float p2max = period - onems - fabsf(swing);
    if (p2max < p2min) {
      p2max = p2min;
    }

    // double p1 = 0.0;// implicit, no need
    double p2 = (double)((p2max - p2min) * pulseWidth + p2min);  // pulseWidth is [0 : 1]
    double p3 = (double)(period + swing);
    double p4 = ((double)(period + swing)) + p2;

    if (step < p2)
      high = 1;
    else if ((step >= p3) && (step < p4))
      high = 2;
  } else if (*resetClockOutputsHigh)
    high = 1;
  return high;
}
